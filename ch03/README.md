# CH03 코드에서 나는 악취

- 리팩터링을 해야할 시점을 설명하는데 냄새라는 표현을 사용했다.

### 3.1 기이한 이름 (*Mysterious Name*)

- 코드를 명료하게 표현하는 중요한 요소 : **이름**
- 함수, 모듈, 변수, 클래스 등의 이름만으로 하는 일 명확하게 파악 가능해야 함
- ***함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기***
- 이름 바꾸기가 어렵다면 -> 설계에 근본적인 문제가 있을 수도 있음

### 3.2 중복 코드(*Duplicated Code*)

- ***함수 추출하기*** : 한 클래스에 두 메서드가 똑같은 표현식 사용 -> 양쪽 모두 추출된 메서드 호출
- ***문장 슬라이드하기***  : 코드가 비슷한데 완전 똑같지 않은 경우 -> 비슷한 부분 모아서 함수 추출하기 적용
- ***메소드 올리기*** : 같은 부모로부터 파생된 서브 클래스에 중복된 코드 있는 경우

### 3.3 긴 함수 (*Long Function*)

- 오랜 기간 활용되는 프로그램 -> 짧은 함수
- 주석이 필요한 부분 -> 함수, 함수 이름 -> 의도(intention)이 드러나게 짓기 (함수의 길이가 중요 X)
- ***함수 추출하기***
- ***임시 변수를 질의 함수로 바꾸기*** : 임시 변수의 수 줄이기
- ***매개변수 객체 만들기***, ***객체 통째로 넘기기*** : 매개변수의 수 줄이기
- ***함수를 명령으로 바꾸기*** : 임시 변수와 매개변수가 위의 리팩터링을 적용해도 많은 경우
- ***조건문 분해하기*** : 조건문 또는 반복문 추출 대상의 실마리
- ***함수 추출하기*** : switch문을 구성하는 case문마다 ***함수 추출하기*** 적용
- ***조건문을 다형성으로 바꾸기*** : 같은 조건을 기준으로 나뉘는 switch문이 여러개인 경우
- ***반복문 쪼개기*** : 반복문 안의 코드도 추출해서 독립된 함수로 만들기 

### 3.4 긴 매개변수 목록 (*Long Parameter List*)

- 암적 존재인 전역 데이터가 늘어나는 사태를 막기 위해 -> 매개변수로 전달
- ***매개변수를 질의 함수로 바꾸기***  : 다른 매개변수에서 값을 얻어올 수 있는 매개변수
- ***객체 통째로 넘기기***  : 데이터 구조에서 값들을 뽑아 각각 별개의 매개변수로 전달하는 경우 -> 원본 데이터 구조 전달  
- ***매개변수 객체 만들기***  : 매개변수들을 하나로 묶기
- ***플래그 인수 제거하기*** :함수의 동작 방식을 정하는 플래그 역할 매개변수 제거
- ***여러 함수를 클래스로 묶기*** : 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 경우 -> 공통 값들을 클래스의 필드로 정의

### 3.5 전역 데이터 (*Global Data*)

- 전역 데이터는 우리가 겪을 수 잇는 악취 중 가장 지독한 축 (코드 베이스 어디에서든 건드릴 수 있고 누가 바꿨는지 찾아낼 메커니즘 없음) 
- ***변수 캡슐화하기*** : 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 적용 -> 데이터를 함수로 감싸서 데이터 수정하는 부분 쉽게 찾고, 접근 통제 가능
  - 접근자 함수들을 클래스나 모듈에 넣고, 그 안에서만 사용할 수 있도록 접근 범위 최소화
- 전역 데이터가 가변이라면 더 까다로움 (프로그램이 구동된 후에는 값이 바뀌지 않는다고 보장할 수 잇는 전역 데이터는 그나마 안전)

### 3.6 가변 데이터 (*Mutable Data*)

- 데이터 변경시 종종 예상치 못한 결과, 버그 발생 -> 원인 알아내기 어려울 수 있음
- ***변수 캡슐화하기*** : 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 -> 수정 감시, 코드 개선 쉬움
- ***변수 쪼개기*** : 하나의 변수에 용도가 다른 값들을. 저장하느라 값이 갱신되는 경우 -> 용도별로 독립 변수에 저장 -> 값 갱신 문제 줄이기
- ***문장 슬라이드하기***, ***함수 추출하기*** : 갱신 로직은 다른 코드와 분리
- ***질의 함수와 변경 함수 분리하기*** : API 만들 때는 부작용이 있는 코드 호출할 수 없게 하기
- ***세터 제거하기*** : 세터(setter) 호출하는 클라이언트 찾기 -> 변수 유효범위 줄일 수 있음
- ***파생 변수를 질의 함수로 바꾸기*** : 값을 다른 곳에서 설정할 수 있는 가변 데이터의 경우
- ***여러 함수를 클래스로 묶기***, ***여러 함수를 변환 함수로 묶기*** : 변수 갱신 코드 유효범위 제한 (클래스나 변환으로)
- ***참조를 값으로 바꾸기*** : 구조체처럼 내부 필드에 데이터를 담고 있는 변수 -> 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체 

### 3.7 뒤엉킨 변경 (*Divergent Change*)

- 코드를 수정할 때 시스템에서 고쳐야 할 딱 한군데를 찾아서 수정할 수 없는 경우
- SRP (단일 책임 원칙)이 제대로 지켜지지 않을 때 나타남 : 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많은 경우 발생 
  - ex) 데이터베이스가 추가될 때마다 함수 세 개를 바꾸고, 금융 상품이 추가될 때마다 또 다른 함수 네 개를 바꿔야하는 모듈 -> 데이터베이스 연동과 금융 상품 처리는 서로 다른 맥락 -> 독립된 모듈로 분리해야함
- ***단계 쪼개기*** : 단계 분리 
- ***함수 옮기기*** : 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높은 경우 -> 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수 모으기 -> 처리 과정 맥락별로 구분 가능 
- ***함수 추출하기*** : 맥락에 관여되는 함수가 있다면 먼저 수행
- ***클래스 추출하기*** : 모듈이 클래스인 경우

### 3.8 산탄총 수술 (*Shotgun Surgery*)

- 코드를 수정할 때 시스템에서 고쳐야 할 딱 한군데를 찾아서 수정할 수 없는 경우
- 뒤엉킨 변경과 비슷하면서도 정반대
- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많은 경우
- ***함수 옮기기***, ***필드 옮기기*** : 변경해야하는 부분이 코드 전반에 퍼져 있는 경우 -> 하나으 ㅣ모듈로 묶기
- ***여러 함수를 클래스로 묶기*** : 비슷한 데이터를 다루는 함수가 많은 경우
- ***여러 함수를 변환 함수로 묶기*** : 데이터 구조를 변환하거나 보강하는 함수
- ***단계 쪼개기*** : 묶은 함수들의 출력 결과를 다음 단계의 로직으로 전달할 수 있는 경우
- ***함수 인라인하기***, ***클래스 인라인하기*** : 어설프게 분리된 로직 -> 인라인 리팩터링으로 합치기

### 3.9 기능 편애 (*Feature Envy*)

- 프로그램 모듈화 할 떄 : 코드를 여러 영역으로 나누고
  - 영역 안에서 이뤄지는 상호작용은 늘리고
  - 영역 사이에서 이뤄지는 상호작용은 최소로 줄인다  
- 기능 편애 : 어떤 함수의 상호작용 -> 자기가 속한 모듈의 함수나 데이터 < 다른 모듈의 함수나 데이터 일 때 풍기는 악취
- ***함수 옮기기*** : 함수가 데이터와 가까이 있고 싶어 하는 경우 
- ***함수 추출하기*** : 함수의 일부 기능 편애 -> 독립 함수
- ***함수 옮기기*** : 원하는 모듈로 보내기
- ***함수 추출하기*** : 함수가 사용하는 모듈이 다양한 경우 -> 가장 많은 데이터를 포함한 모듈로 옮긴다

### 3.10 데이터 뭉치 (*Data Clumps*)

- 데이터 항목 서너 개가 여러 군데서 함께 뭉쳐있는 상태로 발견 되는 경우 -> 따로 묶기 
- ***클래스 추출하기*** : 가장 먼저 필드 형태의 데이터 뭉치를 찾아서 하나의 객체로 묶기
- ***매개변수 객체 만들기***, ***객체 통째로 넘기기*** : 매개변수 수 줄이기

### 3.11 기본형 집착 (*Primitive Obsession*)

- 기초 타입 (화폐, 좌표, 구간 등)을 직접 정의하기 꺼려하는 사람이 있음
- 최소한 사용자에게는 일관된 형식으로 출력해주는 기능을 갖춰야함
- 자료형들을 문자열로만 표현하는 악취 -> **문자열화된**변수
- ***기본형을 객체로 바꾸기*** : 기본형 -> 자료형들
- ***타입 코드를 서브클래스로 바꾸기***, ***조건부 로직을 다형성으로 바꾸기*** : 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰인 경우
- ***클래스 추출하기***, ***매개변수 객체 만들기*** : 기본형 그룹도 데이터 뭉치

### 3.12 반복되는 switch문 (*Repeated Switches*)

- ***조건부 로직을 다형성으로 바꾸기*** : 순수한 객체 지향 신봉하는 사람 -> switch문 모조리 없애야 한다고 주장 (심지어 if문까지) 

### 3.13 반복문 (*Loops*)

- ***반복문을 파이프라인으로 바꾸기*** : 반복문 제거 가능

### 3.14 성의 없는 요소 (*Lazy Element*)

- ***함수 인라인하기***, ***클래스 인라인하기***
- ***계층 합치기***

### 3.15 추측성 일반화 (*Speculative Generality*)

- "나중에 필요할 거야" 라는 생각으로 당장 필요 없는 모든 종류의 후킹 포인터와 특이 케이스 처리 로직을 작성해둔 코드
- ***계층 합치기*** : 하는 일이 거의 없는 추상 클래스
- ***함수 인라인하기***, ***클래스 인라인하기*** : 쓸데없이 위임하는 코드
- ***함수 선언 바꾸기*** : 본문에서 사용되지 않는 매개변수
- ***죽은 코드 제거하기*** : 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스, 테스트 케이스부터 삭제 후 제거

### 3.16 임시 필드 (*Temporary Field*)

- 특정 상황에서만 값이 설정되는 필드를 가진 클래스 -> 당연히 모든 필드가 채워져 있을거라 생각해서 임시 필드를 갖도록 작성하면 코드 이해 어려움
- ***클래스 추출하기*** : 쓰이지 않는 것처럼 보이는 필드 있는 경우
- ***함수 옮기기*** : 임시 필드들과 관련된 코드 -> 새 클래스
- ***특이 케이스 추가*** : 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거

### 3.17 메시지 체인 (*Message Chains*)

- 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 -> 방금 얻은 객체에 또 다른 객체를 요청하는 식
- 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드
- ***위임 숨기기*** : 체인을 구성하는 모든 객체에 적용 가능 -> 하지만 중간 객체들이 모두 중개자가 되기 쉽다
- ***함수 추출하기***, ***함수 옮기기*** : 객체를 사용하는 코드 일부를 추출한 후 체인을 숨길 수 있는지 확인

### 3.18 중개자 (*Middle Man*)

- 객체의 대표적인 기능 : 외부로부터 세부사항을 숨겨주는 캡슐화 -> 이 과정에서 위임(delegation) 활용
- ***중개자 제거하기*** : 실제로 일을 하는 객체와 직접 소통
  - 예를 들어) 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하는 경우
- ***함수 인라인하기*** : 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는쪽으로 인라인

### 3.19 내부자 거래 (*Insider Trading*)

- 모듈 사이의 데이터 거래가 많으면 결합도(Coupling)이 높아짐 -> 최소로 줄여야함
- ***함수 옮기기***, ***필드 옮기기*** : 데이터를 주고받는 모듈의 사적 처리 부분 줄이기 
- ***위임 숨기기*** : 여러 모듈이 같은 관심사를 공유한다면 다른 모듈이 중간자 역할 하게 만듦
  - 또는, 공통 부분을 정식으로 처리하는 제3의 모듈 만들기
- ***서브클래스를 위임으로 바꾸기***, ***슈퍼클래스를 위임으로 바꾸기*** : 상속 구조에서 부모 자식 사이에 결탁이 생기는 경우 -> 부모 품을 떠나야할 떄

### 3.20 거대한 클래스 (*Large Class*)

- 한 클래스 업무 과중 -> 필드 수 증가 -> 중복 코드 발생 확률 높아짐
- ***클래스 추출하기*** : 같은 컴포넌트에 모을만한 필드 일부를 따로 묶기
- ***슈퍼클래스 추출하기***, ***타입코드를 서브클래스로 바꾸기*** : 한 클래스 안에서 접두어나 접미어가 같은 필드들이 함께 추출할 후보들, 분리할 컴포넌트를 원래 클래스와 상속관계로 만드는 것이 좋은 경우

### 3.21 서로 다른 인터페이스의 대안 클래스들 (*Alternative Classes with Different Interfaces*)

- 클래스의 장점 : 인터페이스가 같은 경우 다른 클래스로 교체가 가능
- ***함수 선언 바꾸기*** : 메서드 시그니처 일치
- ***함수 옮기기*** : 인터페이스가 같아질 떄까지 필요한 동작들을 클래스 안으로 밀어 넣기
- ***슈퍼클래스 추출하기*** : 대안 클래스들 사이에 중복 코드가 생기는 경우

### 3.22 데이터 클래스 (*Data Class*)

- 데이터 클래스 : 데이터 필드와 게터/세터 메서드만으로 구성된 클래스
- ***레코드 캡슐화하기*** : public 필드
- ***세터 제거하기*** : 변경하면 안 되는 필드 -> 접근 봉쇄
- ***함수 옮기기*** : 다른 클래스에서 데이터 클래스의 게터나 세터를 사용하는 메서드를 찾기 -> 그 메서드를 데이터 클래스로 옮길 수 있는지
- ***함수 추출하기*** : 메서드 통째로 옮기기 어려운 경우, 옮길 수 있는 부분만 별도의 메서드로 뽑기
- 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호 일 수 있음 -> 클라이언트 코드를 데이터 클래스로 옮기면 대폭 개선
- ***단계 쪼개기*** : 중간 데이터 구조 -> 불변 (mutable)

### 3.23 상속 포기 (*Refused Bequest*)

- 부모로부터 메서드와 데이터를 물려 받는 서브클래스 -> 받기 싫은 경우 / 몇 개만 받고 싶은 경우
- ***메서드 내리기***, ***필드 내리기*** : 먼저 같은 계층에 서브 클래스를 하나 새로 만들기 -> 물려받지 않을 부모 코드를 모조리 새로 만든 서브 클래스로 넘기기 -> 부모는 공통된 부분만 남음
- ***서브 클래스를 위임으로 바꾸기***, ***슈퍼클래스를 위임으로 바꾸기*** : 서브 클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않은 경우 -> 상속 매커니즘에서 벗어나기

### 3.24 주석 (*Comments*)

- 주석은 악취가 아닌 향기를 입힘

- 하지만, 주석이 장황한 경우 -> 코드를 잘못 작성한 경우가 많음 -> 군더더기

- ***주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링 해본다***

- 무조건 하지 말라는 것은 아님.

- 현재 진행 상황, 확실하지 않은 부분에 주석 달면 좋음

- ***함수 추출하기*** : 특정 코드 블록이 하는 일에 주석을 남기고 싶을 때

- ***함수 선언 바꾸기*** : 이미 추출되어 있는 함수인데 설명이 필요할 때

- ***어서션 추가하기*** : 시스템이 동작하기 위한 선행조건 명시

  














