# CH07 캡슐화

### 7.1 레코드 캡슐화하기

- 가변 데이터를 저장하는 용도 : 객체
- 불변 데이터를 저장하는 용도 : 레코드



### 7.2 컬렉션 캡슐화하기

- 컬렉션 : array, list, map, set

- 가변 데이터 캡슐화 -> 데이터 구조 파악 쉬워짐, 변경도 쉬워짐

- 컬렉션 변수로의 접근 캡슐화할 때 게터가 컬렉션 자체를 반환하면 컬렉션 원소가 바뀌는 문제가 발생가능

  -> 컬렉션을 감싼 클래스에 add()와 remove() 컬렉션 변경자 메서드를 만듦

  -> 컬렉션을 소유한 클래스를 통해서만 원소를 변경하도록

  -> 컬렉션 게터가 원본 컬렉션을 반환하지 않도록

  -> 컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환 (세터는 없게)



### 7.3 기본형을 객체로 바꾸기

- 악취 : "기본형 집착"

- 단순한 출력 이상의 기능이 필요해지는 순간 사용 -> 데이터를 표현하는 전용 클래스 정의

  

### 7.4 임시 변수를 질의 함수로 바꾸기

- 코드의 결괏값을 임시 변수 대신 함수로 만들면 비슷한 계산을 수행하는데 편리 (스냅숏 용도 제외)
- 클래스 안에서 적용할 때 효과가 가장 큼
- 한 번만 계산하고, 그 뒤로는 읽기만 해야함



### 7.5 클래스 추출하기

- 메소드와 데이터가 많은 클래스는 적절히 분리하는 것이 좋음



### 7.6 클래스 인라인하기

- "클래스 추출하기"의 반대 



### 7.7 위임 숨기기

- 서버 객체의 필드가 가리키는 객체 (위임 객체)의 메서드를 호출하려면 클라이언트는 이 위임 객체를 알아야 함

  -> 위임 객체의 인터페이스가 바뀌면, 이 인터페이스를 사용하는 모든 클라이언트 코드가 수정되어야 함

  -> 의존성을 없애려면 서버 자체에 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 됨

- 의존성을 없애면 위임 객체가 수정되어도 서버 코드만 고치면 됨



### 7.8 중개자 제거하기

- "위임 숨기기"의 반대
- 위임 객체의 다른 기능을 사용하고 싶을 때마다 위임 메서드 추가하면 -> 직접 호출이 나을 수 있음



### 7.9 알고리즘 교체하기

- 알고리즘 수정


